name: Project - notify on Status changes (cache)

on:
  schedule:
    - cron: "*/15 * * * *"   # cada 15 minutos (UTC)
  workflow_dispatch: {}

# Concurrency para evitar solapamientos si tarda m√°s de 15'
concurrency:
  group: project-status-notify
  cancel-in-progress: true

permissions:
  contents: read
  issues: read

env:
  PROJECT_ID:        ${{ vars.PUBLIC_PROJECT_ID }}
  STATUS_FIELD_ID:   ${{ vars.PUBLIC_STATUS_FIELD_ID }}
  PRIORITY_FIELD_ID: ${{ vars.PUBLIC_PRIORITY_FIELD_ID }}
  ENDDATE_FIELD_ID:  ${{ vars.PUBLIC_ENDDATE_FIELD_ID }}
  SNAP_PATH: .cache/project_status_cache.json

jobs:
  poll:
    runs-on: ubuntu-latest
    steps:
      - name: Restore snapshot cache
        id: restore
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.SNAP_PATH }}
          key: project-status-${{ github.run_id }}
          restore-keys: |
            project-status-

      - name: Ensure snapshot file exists
        run: |
          mkdir -p .cache
          [ -f "${SNAP_PATH}" ] || echo '{}' > "${SNAP_PATH}"

      - name: Fetch current snapshot (Project v2)
        id: curr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const proj = process.env.PROJECT_ID;
            const statusF = process.env.STATUS_FIELD_ID;
            const prioF   = process.env.PRIORITY_FIELD_ID;
            const endF    = process.env.ENDDATE_FIELD_ID;

            const q = `
              query($project:ID!, $after:String){
                node(id:$project){
                  ... on ProjectV2{
                    items(first:100, after:$after){
                      nodes{
                        content{
                          __typename
                          ... on Issue { number title url }
                        }
                        fieldValues(first:50){
                          nodes{
                            __typename
                            ... on ProjectV2ItemFieldSingleSelectValue{
                              name
                              field{ ... on ProjectV2FieldCommon { id } }
                            }
                            ... on ProjectV2ItemFieldDateValue{
                              date
                              field{ ... on ProjectV2FieldCommon { id } }
                            }
                          }
                        }
                      }
                      pageInfo{ hasNextPage endCursor }
                    }
                  }
                }
              }`;

            let after = null, rows = {};
            do {
              const r = await github.graphql(q, { project: proj, after });
              const page = r.node.items;
              for (const it of page.nodes) {
                const c = it.content;
                if (!c || c.__typename !== 'Issue') continue;
                let status=null, priority=null, end=null;
                for (const fv of (it.fieldValues?.nodes||[])) {
                  if (fv.__typename === 'ProjectV2ItemFieldSingleSelectValue') {
                    const fid = fv.field?.id;
                    if (fid === statusF) status = fv.name || null;
                    if (fid === prioF)   priority = fv.name || null;
                  }
                  if (fv.__typename === 'ProjectV2ItemFieldDateValue' && fv.field?.id === endF) {
                    end = fv.date || null;
                  }
                }
                rows[c.number] = { status, priority, end, url: c.url, title: c.title };
              }
              after = page.pageInfo.hasNextPage ? page.pageInfo.endCursor : null;
            } while (after);

            const fs = require('fs');
            fs.writeFileSync('snapshot_now.json', JSON.stringify(rows, null, 2));
            core.setOutput('path', 'snapshot_now.json');

      - name: Diff statuses ‚Üí changes.json
        id: diff
        run: |
          # Compara SNAP_PATH (previo) con snapshot_now.json (actual)
          jq -n --slurpfile P "${SNAP_PATH}" --slurpfile C snapshot_now.json '
            ($P[0] // {}) as $p
            | ($C[0] // {}) as $c
            | ($p + $c) as $u
            | ($u | keys_unsorted) as $ks
            | [ $ks[]
                | { k: ., old: ($p[.].status // null), now: ($c[.].status // null),
                    title: ($c[.].title // $p[.].title), url: ($c[.].url // $p[.].url),
                    priority: ($c[.].priority // $p[.].priority), end: ($c[.].end // $p[.].end) }
                | select(.old != null and .now != null and .old != .now)
                | { num: (.k|tonumber), old, now, title, url, priority, end }
              ]' > changes.json
          echo "CHANGED=$(jq length changes.json)" >> $GITHUB_ENV
          echo "Cambios detectados: $(jq length changes.json)"

      - name: Notify Teams (one compact card per change)
        if: ${{ env.CHANGED != '0' }}
        env:
          HOOK: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          cat changes.json | jq -c '.[]' | while read -r row; do
            NUM=$(echo "$row" | jq -r '.num')
            OLD=$(echo "$row" | jq -r '.old')
            NEW=$(echo "$row" | jq -r '.now')
            TITLE=$(echo "$row" | jq -r '.title')
            URL=$(echo "$row" | jq -r '.url')
            PRI=$(echo "$row" | jq -r '.priority')
            END=$(echo "$row" | jq -r '.end')

            # Emojis por prioridad (P0 rojo, Hito 1 amarillo, Hito 2 azul)
            case "$PRI" in
              P0) PRI_E="üî¥";;
              "Hito 1") PRI_E="üü°";;
              "Hito 2") PRI_E="üîµ";;
              *) PRI_E="‚ö™Ô∏è";;
            esac
            # Emojis por estado
            case "$NEW" in
              Backlog)     ST_E="üî¥";;
              Ready)       ST_E="üîµ";;
              "In progress"|"In Progress") ST_E="üü°";;
              "In review"|"In Review")     ST_E="üü£";;
              Done)        ST_E="üü¢";;
              *)           ST_E="‚ö™Ô∏è";;
            esac
            # Fecha fin dd/mm/yyyy
            if [ -n "$END" ]; then D=${END:8:2}; M=${END:5:2}; Y=${END:0:4}; END_H="$D/$M/$Y"; else END_H=""; fi

            FOOT=""
            [ -n "$PRI" ]   && FOOT="$PRI_E $PRI"
            [ -n "$NEW" ]   && FOOT="${FOOT:+$FOOT   |   }$ST_E $NEW"
            [ -n "$END_H" ] && FOOT="${FOOT:+$FOOT   |   }üìÖ $END_H"

            # Adaptive Card compacta
            jq -n --arg h "üîÅ Status cambiado en issue #$NUM: $OLD ‚Üí $NEW" \
                  --arg t "$TITLE" \
                  --arg u "$URL" \
                  --arg foot "$FOOT" '
            {
              type:"message",
              attachments:[{
                contentType:"application/vnd.microsoft.card.adaptive",
                content:{
                  "$schema":"http://adaptivecards.io/schemas/adaptive-card.json",
                  type:"AdaptiveCard", version:"1.5",
                  body:[
                    {type:"TextBlock", size:"Small", isSubtle:true, weight:"Bolder", text:$h},
                    {type:"TextBlock", size:"Medium", weight:"Bolder", wrap:true, text: ("[" + $t + "](" + $u + ")") },
                    {type:"TextBlock", isSubtle:true, spacing:"Small", wrap:true, text:$foot}
                  ],
                  actions:[{type:"Action.OpenUrl", title:"Ver en GitHub", url:$u}]
                }
              }]
            }' > payload.json

            curl -sS -X POST "$HOOK" -H "Content-Type: application/json" --data-binary @payload.json
          done

      - name: Prepare new snapshot for cache
        run: |
          mkdir -p .cache
          mv -f snapshot_now.json "${SNAP_PATH}"

      - name: Save snapshot cache
        uses: actions/cache/save@v4
        with:
          path: ${{ env.SNAP_PATH }}
          key: project-status-${{ github.run_id }}
          # retention-days: 14  # (opcional, si tu organizaci√≥n lo permite)
