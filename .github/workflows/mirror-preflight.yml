name: Mirror Preflight

on:
  workflow_dispatch: {}   # botÃ³n Run workflow
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]

permissions:
  contents: read
  issues: read

env:
  PUBLIC_OWNER: santiago-larrain
  PUBLIC_REPO:  public-iee3112-proyecto-sec
  MIRROR_LABEL: public
  COPY_COMMENTS: true

jobs:
  preflight:
    runs-on: ubuntu-latest
    steps:
      - name: Who am I (PAT holder)?
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const { data: me } = await github.rest.users.getAuthenticated();
            core.info(`Authenticated as: ${me.login} (id=${me.id})`);

      - name: Can PAT access the target repo?
        id: can_access
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const owner = process.env.PUBLIC_OWNER;
            const repo  = process.env.PUBLIC_REPO;
            try {
              const { data } = await github.rest.repos.get({ owner, repo });
              core.info(`OK: Found ${data.full_name}, has_issues=${data.has_issues}`);
              if (!data.has_issues) core.setFailed("Issues are disabled in target repo.");
            } catch (e) {
              core.setFailed(`Cannot access ${owner}/${repo} with MIRROR_TOKEN: ${e.status} ${e.message}`);
            }

  mirror:
    if: ${{ github.event_name != 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check label gate (only if issue has MIRROR_LABEL)
        id: checklabel
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.payload.issue) {
              const labels = context.payload.issue.labels.map(l => typeof l === 'string' ? l : l.name);
              core.setOutput('allowed', String(labels.includes(process.env.MIRROR_LABEL)));
            } else {
              core.setOutput('allowed', 'false');
            }

      - name: Stop if not labeled for mirroring
        if: steps.checklabel.outputs.allowed != 'true'
        run: echo "Issue not labeled 'public'. Skipping."

      - name: Mirror/Sync to public
        if: steps.checklabel.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const pubOwner = process.env.PUBLIC_OWNER;
            const pubRepo  = process.env.PUBLIC_REPO;
            const srcIssue = context.payload.issue;
            const srcNumber = srcIssue.number;

            function sanitize(t){ if(!t) return ''; return t.split('\n').filter(l=>!/(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i.test(l)).join('\n').trim(); }

            const header = `> ðŸ”— Source: ${context.repo.owner}/${context.repo.repo}#${srcNumber}`;
            const mirroredBody = `${header}\n\n${sanitize(srcIssue.body||'')}\n\n<!-- MIRROR-SOURCE:${context.repo.owner}/${context.repo.repo}#${srcNumber} -->`;

            // Create (first time) or update mapped issue
            async function findMapping() {
              const { data: comments } = await github.rest.issues.listComments({ owner: context.repo.owner, repo: context.repo.repo, issue_number: srcNumber, per_page: 100 });
              const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
              for (const c of comments) {
                const m = c.body && c.body.match(marker);
                if (m) return { owner: m[1], repo: m[2], number: Number(m[3]) };
              }
              return null;
            }

            async function writeMapping(targetNumber) {
              const marker = `<!-- MIRROR-TARGET:${pubOwner}/${pubRepo}#${targetNumber} -->`;
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: srcNumber, body: `Mirrored to ${pubOwner}/${pubRepo}#${targetNumber}\n\n${marker}` });
            }

            let mapping = await findMapping();

            if (!mapping) {
              try {
                const { data: created } = await github.rest.issues.create({ owner: pubOwner, repo: pubRepo, title: srcIssue.title, body: mirroredBody, labels: ['from-private'] });
                await writeMapping(created.number);
                mapping = { owner: pubOwner, repo: pubRepo, number: created.number };
              } catch (e) {
                core.setFailed(`Create issue failed on ${pubOwner}/${pubRepo}: ${e.status} ${e.message}`);
                return;
              }
            }

            try {
              await github.rest.issues.update({ owner: mapping.owner, repo: mapping.repo, issue_number: mapping.number, title: srcIssue.title, body: mirroredBody });
            } catch (e) {
              core.setFailed(`Update issue failed on ${mapping.owner}/${mapping.repo}#${mapping.number}: ${e.status} ${e.message}`);
            }
