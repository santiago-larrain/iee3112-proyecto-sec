name: Mirror public issues

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: read

env:
  PUBLIC_OWNER: ${{ vars.PUBLIC_OWNER }}
  PUBLIC_REPO:  ${{ vars.PUBLIC_REPO }}
  MIRROR_LABEL: ${{ vars.MIRROR_LABEL || 'public' }}
  COPY_COMMENTS: ${{ vars.COPY_COMMENTS || 'true' }}

jobs:
  mirror:
    if: ${{ github.event_name == 'issues' || github.event_name == 'issue_comment' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check label gate (only proceed if issue has MIRROR_LABEL)
        id: checklabel
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.payload.issue) {
              const labels = context.payload.issue.labels.map(l => typeof l === 'string' ? l : l.name);
              const has = labels.includes(process.env.MIRROR_LABEL);
              core.setOutput('allowed', String(has));
            } else {
              core.setOutput('allowed', 'false');
            }
      - name: Stop if not labeled for mirroring
        if: steps.checklabel.outputs.allowed != 'true'
        run: echo "Issue not labeled for mirroring. Skipping."

      - name: Mirror/Sync to public
        if: steps.checklabel.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const pubOwner = process.env.PUBLIC_OWNER;
            const pubRepo  = process.env.PUBLIC_REPO;
            if (!pubOwner || !pubRepo) {
              core.setFailed("PUBLIC_OWNER and PUBLIC_REPO must be set as repo variables.");
            }

            const srcIssue = context.payload.issue;
            const srcNumber = srcIssue.number;

            // Helper: sanitize body (very b√°sico ‚Äì ajusta a tu pol√≠tica)
            function sanitize(text) {
              if (!text) return '';
              let t = text;
              // Borra l√≠neas con palabras t√≠picas de secretos
              const danger = /(token|secret|password|passwd|apikey|api-key|authorization|bearer|ssh-|PRIVATE KEY)/i;
              t = t.split('\n').filter(line => !danger.test(line)).join('\n');
              // Borra par√°metros de query (?...=...) de URLs
              t = t.replace(/\bhttps?:\/\/[^\s)]+/g, (u) => {
                try {
                  const url = new URL(u);
                  url.search = '';
                  return url.toString();
                } catch { return u; }
              });
              return t.trim();
            }

            // Encabezado y pie para identificar el origen
            const header = `> üîó Source: ${context.repo.owner}/${context.repo.repo}#${srcNumber}`;
            const bodySafe = sanitize(srcIssue.body || '');
            const mirroredBody = `${header}\n\n${bodySafe}\n\n<!-- MIRROR-SOURCE:${context.repo.owner}/${context.repo.repo}#${srcNumber} -->`;

            // Buscamos si ya existe mapping en un comentario de la privada
            async function findMappingInPrivateComment() {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: srcNumber,
                per_page: 100
              });
              const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
              for (const c of comments) {
                const m = c.body && c.body.match(marker);
                if (m) return { owner: m[1], repo: m[2], number: Number(m[3]), commentId: c.id };
              }
              return null;
            }

            async function writeMappingComment(targetNumber) {
              const marker = `<!-- MIRROR-TARGET:${pubOwner}/${pubRepo}#${targetNumber} -->`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: srcNumber,
                body: `Mirrored to ${pubOwner}/${pubRepo}#${targetNumber}\n\n${marker}`
              });
            }

            let mapping = await findMappingInPrivateComment();

            // Si el evento es "issues"
            if (context.eventName === 'issues') {
              const action = context.payload.action;
              if (!mapping) {
                // Crear issue p√∫blica
                const { data: created } = await github.rest.issues.create({
                  owner: pubOwner,
                  repo: pubRepo,
                  title: srcIssue.title,
                  body: mirroredBody,
                  labels: ['from-private']
                });
                await writeMappingComment(created.number);
                mapping = { owner: pubOwner, repo: pubRepo, number: created.number };
              } else {
                // Asegura que el target est√© en el repo esperado (por si moviste variables)
                if (mapping.owner !== pubOwner || mapping.repo !== pubRepo) {
                  core.warning(`Mapping points to ${mapping.owner}/${mapping.repo}#${mapping.number}, but variables point to ${pubOwner}/${pubRepo}. Using mapping.`);
                }
              }

              // Sync seg√∫n acci√≥n
              if (['opened','edited','labeled','unlabeled'].includes(action)) {
                // Actualiza t√≠tulo y cuerpo
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  title: srcIssue.title,
                  body: mirroredBody
                });
              }
              if (action === 'closed') {
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  state: 'closed'
                });
              }
              if (action === 'reopened') {
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  state: 'open'
                });
              }
            }

            // Si el evento es "issue_comment" y quieres copiar comentarios
            if (context.eventName === 'issue_comment') {
              if ((process.env.COPY_COMMENTS || 'true').toLowerCase() !== 'true') {
                core.info('COPY_COMMENTS disabled. Skipping comment mirroring.');
                return;
              }
              const comment = context.payload.comment;
              // Ignora comentarios del propio bot para evitar loops
              if (comment.user && comment.user.type === 'Bot') return;

              if (!mapping) {
                // Si a√∫n no hay issue p√∫blica, cr√©ala primero
                const { data: created } = await github.rest.issues.create({
                  owner: pubOwner,
                  repo: pubRepo,
                  title: srcIssue.title,
                  body: mirroredBody,
                  labels: ['from-private']
                });
                await writeMappingComment(created.number);
                mapping = { owner: pubOwner, repo: pubRepo, number: created.number };
              }

              // Sanitiza comentario
              const safeComment = sanitize(comment.body || '');
              if (safeComment) {
                await github.rest.issues.createComment({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  body: safeComment
                });
              }
            }
