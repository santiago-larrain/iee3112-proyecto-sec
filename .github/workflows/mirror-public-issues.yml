name: Mirror public issues

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

env:
  PUBLIC_OWNER: santiago-larrain
  PUBLIC_REPO:  public-iee3112-proyecto-sec
  MIRROR_LABEL: public
  COPY_COMMENTS: true

jobs:
  # -------------------- SYNC DE ISSUES (tÃ­tulo/cuerpo/estado) --------------------
  mirror_issue:
    if: ${{ github.event_name == 'issues' }}
    runs-on: ubuntu-latest
    steps:
      - name: Gate - issue tiene la etiqueta requerida (privado)
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labels = (context.payload.issue?.labels || []).map(l => typeof l === 'string' ? l : l.name);
            core.setOutput('allowed', labels.includes(process.env.MIRROR_LABEL) ? 'true' : 'false');

      - name: Stop if not labeled
        if: ${{ steps.gate.outputs.allowed != 'true' }}
        run: echo "Issue without '${{ env.MIRROR_LABEL }}' label. Skipping."

      - name: Preflight public repo access (usa MIRROR_TOKEN)
        if: ${{ steps.gate.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const { data } = await github.rest.repos.get({ owner: process.env.PUBLIC_OWNER, repo: process.env.PUBLIC_REPO });
            if (!data.has_issues) core.setFailed('Issues are disabled in target public repo.');

      - name: Build payload & find mapping (privado)
        id: prep
        if: ${{ steps.gate.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const src = context.payload.issue;
            const num = src.number;

            function sanitize(text) {
              if (!text) return '';
              let t = text;
              const danger = /(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i;
              t = t.split('\n').filter(line => !danger.test(line)).join('\n');
              return t.trim();
            }

            const header = `> ðŸ”— Source: ${context.repo.owner}/${context.repo.repo}#${num}`;
            const bodySafe = sanitize(src.body || '');
            const mirroredBody = `${header}\n\n${bodySafe}\n\n<!-- MIRROR-SOURCE:${context.repo.owner}/${context.repo.repo}#${num} -->`;

            // Buscar mapping (comentario con marcador) en la PRIVADA
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: num,
              per_page: 100
            });
            const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
            let pubNumber = '';
            for (const c of comments) {
              const m = c.body && c.body.match(marker);
              if (m) { pubNumber = String(m[3]); break; }
            }

            core.setOutput('title', src.title);
            core.setOutput('body',  mirroredBody);
            core.setOutput('src_number', String(num));
            core.setOutput('pub_number', pubNumber);

      - name: Create public issue (first time)  # usa MIRROR_TOKEN
        id: create_public
        if: ${{ steps.prep.outputs.pub_number == '' }}
        uses: actions/github-script@v7
        env:
          TITLE: ${{ steps.prep.outputs.title }}
          BODY:  ${{ steps.prep.outputs.body }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const { data: created } = await github.rest.issues.create({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              title: process.env.TITLE,
              body:  process.env.BODY,
              labels: ['from-private']
            });
            core.setOutput('pub_number', String(created.number));

      - name: Write mapping marker in private issue  # usa GITHUB_TOKEN
        if: ${{ steps.prep.outputs.pub_number == '' && steps.create_public.outputs.pub_number != '' }}
        uses: actions/github-script@v7
        env:
          SRC_NUMBER: ${{ steps.prep.outputs.src_number }}
          PUB_NUMBER: ${{ steps.create_public.outputs.pub_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const srcNum = Number(process.env.SRC_NUMBER);
            const pubNum = Number(process.env.PUB_NUMBER);
            const marker = `<!-- MIRROR-TARGET:${process.env.PUBLIC_OWNER}/${process.env.PUBLIC_REPO}#${pubNum} -->`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: srcNum,
              body: `Mirrored to ${process.env.PUBLIC_OWNER}/${process.env.PUBLIC_REPO}#${pubNum}\n\n${marker}`
            });

      - name: Pick public issue number
        id: pick
        run: echo "PUB_NUM=${PUB_NUM}" >> $GITHUB_ENV
        env:
          PUB_NUM: ${{ steps.prep.outputs.pub_number != '' && steps.prep.outputs.pub_number || steps.create_public.outputs.pub_number }}

      - name: Sync title/body to public  # usa MIRROR_TOKEN
        if: ${{ env.PUB_NUM != '' }}
        uses: actions/github-script@v7
        env:
          PUB_NUM: ${{ env.PUB_NUM }}
          TITLE:   ${{ steps.prep.outputs.title }}
          BODY:    ${{ steps.prep.outputs.body }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            await github.rest.issues.update({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              title: process.env.TITLE,
              body:  process.env.BODY
            });

      - name: Sync state (open/closed) to public  # usa MIRROR_TOKEN
        if: ${{ env.PUB_NUM != '' && (github.event.action == 'closed' || github.event.action == 'reopened') }}
        uses: actions/github-script@v7
        env:
          PUB_NUM: ${{ env.PUB_NUM }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            await github.rest.issues.update({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              state: (context.payload.action === 'closed') ? 'closed' : 'open'
            });
            
      # === AÃ±adir la issue pÃºblica al Project v2 ===
      - name: Add issue to Project v2 (public)
        id: add_to_project
        uses: actions/github-script@v7
        env:
          PROJECT_ID: ${{ vars.PUBLIC_PROJECT_ID }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}   # PAT clÃ¡sico con scope project
          script: |
            // 1) Obtener node_id de la issue pÃºblica
            const { data: pub } = await github.rest.issues.get({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM)
            });
            const issueNodeId = pub.node_id;

            // 2) AÃ±adir al Project v2
            const mutation = `
              mutation($project:ID!, $content:ID!) {
                addProjectV2ItemById(input:{projectId:$project, contentId:$content}) {
                  item { id }
                }
              }`;
            const r = await github.graphql(mutation, {
              project: process.env.PROJECT_ID,
              content: issueNodeId
            });
            core.setOutput('item_id', r.addProjectV2ItemById.item.id);

      # === Copiar labels del PRIVADO al PÃšBLICO (merge seguro) ===
      - name: Mirror labels to public
        if: ${{ env.PUB_NUM != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const srcLabels = (context.payload.issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const { data: pubIssue } = await github.rest.issues.get({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM)
            });
            const current = pubIssue.labels.map(l => typeof l === 'string' ? l : l.name);
            const next = [...new Set([...current, ...srcLabels])];
            await github.rest.issues.setLabels({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              labels: next
            });

      # === Copiar assignees (solo si tienen acceso al repo pÃºblico) ===
      - name: Mirror assignees to public (best-effort)
        if: ${{ env.PUB_NUM != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const assignees = (context.payload.issue.assignees || []).map(a => a.login);
            if (!assignees.length) return;

            const ok = [];
            for (const u of assignees) {
              try {
                await github.rest.repos.checkCollaborator({
                  owner: process.env.PUBLIC_OWNER,
                  repo:  process.env.PUBLIC_REPO,
                  username: u
                });
                ok.push(u);
              } catch { /* no es colaborador: se omite */ }
            }
            if (!ok.length) return;
            await github.rest.issues.addAssignees({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              assignees: ok
            });

      # === Escribir campos del Project (Status/Priority/Size/Estimate/Fechas) ===
      - name: Update Project fields (status/priority/size/estimate/dates)
        if: ${{ steps.add_to_project.outputs.item_id != '' }}
        uses: actions/github-script@v7
        env:
          ITEM_ID:             ${{ steps.add_to_project.outputs.item_id }}
          STATUS_FIELD_ID:     ${{ vars.PUBLIC_STATUS_FIELD_ID }}
          PRIORITY_FIELD_ID:   ${{ vars.PUBLIC_PRIORITY_FIELD_ID }}
          SIZE_FIELD_ID:       ${{ vars.PUBLIC_SIZE_FIELD_ID }}
          ESTIMATE_FIELD_ID:   ${{ vars.PUBLIC_ESTIMATE_FIELD_ID }}
          STARTDATE_FIELD_ID:  ${{ vars.PUBLIC_STARTDATE_FIELD_ID }}
          ENDDATE_FIELD_ID:    ${{ vars.PUBLIC_ENDDATE_FIELD_ID }}
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}   # PAT clÃ¡sico
          script: |
            // ====== 1) Derivar valores desde la issue PRIVADA ======
            const src = context.payload.issue;
            const labels = (src.labels || []).map(l => typeof l === 'string' ? l : l.name);

            // Status (usa tus opciones del Project: Backlog, Ready, In progress, In review, Done)
            let status = 'Backlog';
            if (labels.includes('Ready')) status = 'Ready';
            if (labels.includes('In progress') || labels.some(n=>/^status\/in-?progress$/i.test(n))) status = 'In progress';
            if (labels.includes('In review')) status = 'In review';
            if (src.state === 'closed' || labels.includes('Done')) status = 'Done';

            // Priority (opciones: P0, Hito 1, Hito 2)
            let priority = null;
            if (labels.includes('P0')) priority = 'P0';
            else if (labels.includes('Hito 1')) priority = 'Hito 1';
            else if (labels.includes('Hito 2')) priority = 'Hito 2';

            // Size (XS/S/M/L/XL). Busca en labels o "size: M" en el cuerpo
            let size = labels.find(l => /^(XS|S|M|L|XL)$/i.test(l)) || null;
            if (!size) {
              const m = /size\s*:\s*(XS|S|M|L|XL)/i.exec(src.body || '');
              if (m) size = m[1].toUpperCase();
            }

            // Estimate (nÃºmero en el body: "estimate: 5")
            let estimate = null;
            {
              const m = /estimate\s*:\s*([0-9]+(\.[0-9]+)?)/i.exec(src.body || '');
              if (m) estimate = parseFloat(m[1]);
            }

            // Fechas en el body: "start date: YYYY-MM-DD", "end date: YYYY-MM-DD"
            function pickDate(re) {
              const m = re.exec(src.body || '');
              return m ? m[1] : null;
            }
            const startDate = pickDate(/start\s*date\s*:\s*(\d{4}-\d{2}-\d{2})/i);
            const endDate   = pickDate(/end\s*date\s*:\s*(\d{4}-\d{2}-\d{2})/i);

            // ====== 2) Mutaciones Project v2 ======
            const setSelect = `
              mutation($project:ID!, $item:ID!, $field:ID!, $name:String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$project, itemId:$item,
                  fieldId:$field, value:{ singleSelectOptionName:$name }
                }) { projectV2Item { id } }
              }`;
            const setNumber = `
              mutation($project:ID!, $item:ID!, $field:ID!, $val:Float!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$project, itemId:$item,
                  fieldId:$field, value:{ number:$val }
                }) { projectV2Item { id } }
              }`;
            const setDate = `
              mutation($project:ID!, $item:ID!, $field:ID!, $val:Date!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$project, itemId:$item,
                  fieldId:$field, value:{ date:$val }
                }) { projectV2Item { id } }
              }`;

            // Status (siempre)
            await github.graphql(setSelect, {
              project: process.env.PUBLIC_PROJECT_ID,
              item:    process.env.ITEM_ID,
              field:   process.env.STATUS_FIELD_ID,
              name:    status
            });

            // Priority
            if (priority) {
              await github.graphql(setSelect, {
                project: process.env.PUBLIC_PROJECT_ID,
                item:    process.env.ITEM_ID,
                field:   process.env.PRIORITY_FIELD_ID,
                name:    priority
              });
            }

            // Size
            if (size) {
              await github.graphql(setSelect, {
                project: process.env.PUBLIC_PROJECT_ID,
                item:    process.env.ITEM_ID,
                field:   process.env.SIZE_FIELD_ID,
                name:    size.toUpperCase()
              });
            }

            // Estimate
            if (estimate !== null) {
              await github.graphql(setNumber, {
                project: process.env.PUBLIC_PROJECT_ID,
                item:    process.env.ITEM_ID,
                field:   process.env.ESTIMATE_FIELD_ID,
                val:     estimate
              });
            }

            // Fechas
            if (startDate) {
              await github.graphql(setDate, {
                project: process.env.PUBLIC_PROJECT_ID,
                item:    process.env.ITEM_ID,
                field:   process.env.STARTDATE_FIELD_ID,
                val:     startDate
              });
            }
            if (endDate) {
              await github.graphql(setDate, {
                project: process.env.PUBLIC_PROJECT_ID,
                item:    process.env.ITEM_ID,
                field:   process.env.ENDDATE_FIELD_ID,
                val:     endDate
              });
            }

  # -------------------- SYNC DE COMENTARIOS (privado -> pÃºblico) --------------------
  mirror_comment:
    if: ${{ github.event_name == 'issue_comment' }}  # <- sin 'env' aquÃ­
    runs-on: ubuntu-latest
    steps:
      - name: Skip whole job if COPY_COMMENTS is false
        id: copygate
        run: |
          if [ "${COPY_COMMENTS}" != "true" ]; then
            echo "COPY_COMMENTS is false; exiting."
            exit 78
          fi

      - name: Gate - issue tiene la etiqueta requerida (privado)
        id: gatec
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labels = (context.payload.issue?.labels || []).map(l => typeof l === 'string' ? l : l.name);
            core.setOutput('allowed', labels.includes(process.env.MIRROR_LABEL) ? 'true' : 'false');

      - name: Stop if not labeled
        if: ${{ steps.gatec.outputs.allowed != 'true' }}
        run: echo "Issue without '${{ env.MIRROR_LABEL }}' label. Skipping comment."

      - name: Find mapping in private issue
        id: findmapc
        if: ${{ steps.gatec.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const num = context.payload.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: num,
              per_page: 100
            });
            const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
            let pubNumber = '';
            for (const c of comments) {
              const m = c.body && c.body.match(marker);
              if (m) { pubNumber = String(m[3]); break; }
            }
            core.setOutput('pub_number', pubNumber);

      - name: Skip if no mapping
        if: ${{ steps.findmapc.outputs.pub_number == '' }}
        run: echo "No mapping. Skipping."

      - name: Mirror new comment to public  # usa MIRROR_TOKEN
        if: ${{ steps.findmapc.outputs.pub_number != '' && github.event.comment.user.type != 'Bot' }}
        uses: actions/github-script@v7
        env:
          PUB_NUM: ${{ steps.findmapc.outputs.pub_number }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            function sanitize(t){
              if(!t) return '';
              return t.split('\n').filter(l=>!/(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i.test(l)).join('\n').trim();
            }
            const body = sanitize(context.payload.comment.body || '');
            if (!body) return;
            await github.rest.issues.createComment({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              body
            });
