name: Mirror public issues

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

env:
  PUBLIC_OWNER: santiago-larrain                  # dueÃ±o del repo PÃšBLICO
  PUBLIC_REPO:  public-iee3112-proyecto-sec       # nombre del repo PÃšBLICO
  MIRROR_LABEL: public                            # etiqueta en la privada que habilita el espejo
  COPY_COMMENTS: true                              # copiar comentarios privado -> pÃºblico

jobs:
  # ----------------- SINCRONIZA ISSUE (tÃ­tulo/cuerpo/estado) -----------------
  mirror_issue:
    if: ${{ github.event_name == 'issues' }}
    runs-on: ubuntu-latest
    steps:
      # Gate: sÃ³lo procede si la issue privada tiene la etiqueta MIRROR_LABEL
      - name: Check label gate (private)
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labels = (context.payload.issue?.labels || []).map(l => typeof l === 'string' ? l : l.name);
            core.setOutput('allowed', labels.includes(process.env.MIRROR_LABEL) ? 'true' : 'false');

      - name: Stop if not labeled
        if: ${{ steps.gate.outputs.allowed != 'true' }}
        run: echo "Issue without '${{ env.MIRROR_LABEL }}' label. Skipping."

      # Preflight: Â¿el PAT ve el repo pÃºblico y tiene Issues activas?
      - name: Preflight public repo access
        if: ${{ steps.gate.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const { data } = await github.rest.repos.get({ owner: process.env.PUBLIC_OWNER, repo: process.env.PUBLIC_REPO });
            if (!data.has_issues) core.setFailed('Issues are disabled in target public repo.');

      # Construir payload y buscar mapping en comentarios PRIVADOS
      - name: Build payload & find mapping (private)
        id: prep
        if: ${{ steps.gate.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const src = context.payload.issue;
            const num = src.number;

            function sanitize(text) {
              if (!text) return '';
              let t = text;
              const danger = /(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i;
              t = t.split('\n').filter(line => !danger.test(line)).join('\n');
              return t.trim();
            }

            const header = `> ðŸ”— Source: ${context.repo.owner}/${context.repo.repo}#${num}`;
            const bodySafe = sanitize(src.body || '');
            const mirroredBody = `${header}\n\n${bodySafe}\n\n<!-- MIRROR-SOURCE:${context.repo.owner}/${context.repo.repo}#${num} -->`;
            const bodyB64 = Buffer.from(mirroredBody, 'utf8').toString('base64');

            // Buscar mapping (comentario con marcador) en la PRIVADA
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: num,
              per_page: 100
            });
            const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
            let pubNumber = '';
            for (const c of comments) {
              const m = c.body && c.body.match(marker);
              if (m) { pubNumber = String(m[3]); break; }
            }

            core.setOutput('title', src.title);
            core.setOutput('src_number', String(num));
            core.setOutput('body_b64', bodyB64);
            core.setOutput('pub_number', pubNumber);

      # Crear issue PÃšBLICA si no existe (usa MIRROR_TOKEN)
      - name: Create public issue (first time)
        id: create
        if: ${{ steps.prep.outputs.pub_number == '' }}
        uses: actions/github-script@v7
        env:
          TITLE:    ${{ steps.prep.outputs.title }}
          BODY_B64: ${{ steps.prep.outputs.body_b64 }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const title = process.env.TITLE;
            const body  = Buffer.from(process.env.BODY_B64, 'base64').toString('utf8');
            const { data: created } = await github.rest.issues.create({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              title,
              body,
              labels: ['from-private']
            });
            core.setOutput('pub_number', String(created.number));

      # Escribir el mapping en la PRIVADA (usa GITHUB_TOKEN)
      - name: Write mapping marker (private)
        if: ${{ steps.prep.outputs.pub_number == '' && steps.create.outputs.pub_number != '' }}
        uses: actions/github-script@v7
        env:
          SRC_NUMBER: ${{ steps.prep.outputs.src_number }}
          PUB_NUMBER: ${{ steps.create.outputs.pub_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const srcNum = Number(process.env.SRC_NUMBER);
            const pubNum = Number(process.env.PUB_NUMBER);
            const marker = `<!-- MIRROR-TARGET:${process.env.PUBLIC_OWNER}/${process.env.PUBLIC_REPO}#${pubNum} -->`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: srcNum,
              body: `Mirrored to ${process.env.PUBLIC_OWNER}/${process.env.PUBLIC_REPO}#${pubNum}\n\n${marker}`
            });

      # Establecer el nÃºmero pÃºblico definitivo (creado o existente)
      - name: Pick public issue number
        id: pick
        run: echo "PUB_NUM=${PUB_NUM}" >> $GITHUB_ENV
        env:
          PUB_NUM: ${{ steps.prep.outputs.pub_number != '' && steps.prep.outputs.pub_number || steps.create.outputs.pub_number }}

      # Sincronizar tÃ­tulo/cuerpo en la PÃšBLICA (MIRROR_TOKEN)
      - name: Sync title/body (public)
        if: ${{ env.PUB_NUM != '' }}
        uses: actions/github-script@v7
        env:
          PUB_NUM:  ${{ env.PUB_NUM }}
          TITLE:    ${{ steps.prep.outputs.title }}
          BODY_B64: ${{ steps.prep.outputs.body_b64 }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const issue_number = Number(process.env.PUB_NUM);
            const title = process.env.TITLE;
            const body  = Buffer.from(process.env.BODY_B64, 'base64').toString('utf8');
            await github.rest.issues.update({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number,
              title, body
            });

      # Sincronizar estado (open/closed) en la PÃšBLICA (MIRROR_TOKEN)
      - name: Sync state (public)
        if: ${{ env.PUB_NUM != '' && (github.event.action == 'closed' || github.event.action == 'reopened') }}
        uses: actions/github-script@v7
        env:
          PUB_NUM: ${{ env.PUB_NUM }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            await github.rest.issues.update({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              state: (context.payload.action === 'closed') ? 'closed' : 'open'
            });

  # ----------------- SINCRONIZA COMENTARIOS (privado -> pÃºblico) -----------------
  mirror_comment:
    if: ${{ github.event_name == 'issue_comment' && ${{ env.COPY_COMMENTS }} == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check label gate for comments (private)
        id: gatec
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labels = (context.payload.issue?.labels || []).map(l => typeof l === 'string' ? l : l.name);
            core.setOutput('allowed', labels.includes(process.env.MIRROR_LABEL) ? 'true' : 'false');

      - name: Stop if not labeled
        if: ${{ steps.gatec.outputs.allowed != 'true' }}
        run: echo "Issue without '${{ env.MIRROR_LABEL }}' label. Skipping comment."

      # Buscar mapping en la PRIVADA
      - name: Find mapping (private)
        id: findmap
        if: ${{ steps.gatec.outputs.allowed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const num = context.payload.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: num,
              per_page: 100
            });
            const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
            let pubNumber = '';
            for (const c of comments) {
              const m = c.body && c.body.match(marker);
              if (m) { pubNumber = String(m[3]); break; }
            }
            core.setOutput('pub_number', pubNumber);

      - name: Skip if no mapping
        if: ${{ steps.findmap.outputs.pub_number == '' }}
        run: echo "No mapping. Skipping."

      # Copiar comentario al PÃšBLICO (MIRROR_TOKEN)
      - name: Mirror new comment (public)
        if: ${{ steps.findmap.outputs.pub_number != '' && github.event.comment.user.type != 'Bot' }}
        uses: actions/github-script@v7
        env:
          PUB_NUM: ${{ steps.findmap.outputs.pub_number }}
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            function sanitize(t){
              if(!t) return '';
              return t.split('\n').filter(l=>!/(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i.test(l)).join('\n').trim();
            }
            const body = sanitize(context.payload.comment.body || '');
            if (!body) return;
            await github.rest.issues.createComment({
              owner: process.env.PUBLIC_OWNER,
              repo:  process.env.PUBLIC_REPO,
              issue_number: Number(process.env.PUB_NUM),
              body
            });
