name: Mirror public issues

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened, closed]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: read

env:
  PUBLIC_OWNER: santiago-larrain        # <-- dueÃ±o del repo pÃºblico
  PUBLIC_REPO:  public-iee3112-proyecto-sec   # <-- nombre del repo pÃºblico
  MIRROR_LABEL: public
  COPY_COMMENTS: true

jobs:
  mirror:
    if: ${{ github.event_name == 'issues' || github.event_name == 'issue_comment' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check label gate (solo corre si la issue tiene la etiqueta)
        id: checklabel
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.payload.issue) {
              const labels = context.payload.issue.labels.map(l => typeof l === 'string' ? l : l.name);
              const has = labels.includes(process.env.MIRROR_LABEL);
              core.setOutput('allowed', String(has));
            } else {
              core.setOutput('allowed', 'false');
            }

      - name: Stop if not labeled for mirroring
        if: steps.checklabel.outputs.allowed != 'true'
        run: echo "Issue not labeled for mirroring. Skipping."

      - name: Mirror/Sync to public
        if: steps.checklabel.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const pubOwner = process.env.PUBLIC_OWNER;
            const pubRepo  = process.env.PUBLIC_REPO;
            const srcIssue = context.payload.issue;
            const srcNumber = srcIssue.number;

            // Saneamos el contenido para no filtrar secretos
            function sanitize(text) {
              if (!text) return '';
              let t = text;
              const danger = /(token|secret|password|apikey|PRIVATE KEY|authorization|bearer)/i;
              t = t.split('\n').filter(line => !danger.test(line)).join('\n');
              return t.trim();
            }

            const header = `> ðŸ”— Source: ${context.repo.owner}/${context.repo.repo}#${srcNumber}`;
            const bodySafe = sanitize(srcIssue.body || '');
            const mirroredBody = `${header}\n\n${bodySafe}\n\n<!-- MIRROR-SOURCE:${context.repo.owner}/${context.repo.repo}#${srcNumber} -->`;

            // Buscamos si ya existe una issue pÃºblica vinculada
            async function findMappingInPrivateComment() {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: srcNumber,
                per_page: 100
              });
              const marker = /<!--\s*MIRROR-TARGET:\s*([^\s#\/]+)\/([^\s#]+)#(\d+)\s*-->/;
              for (const c of comments) {
                const m = c.body && c.body.match(marker);
                if (m) return { owner: m[1], repo: m[2], number: Number(m[3]) };
              }
              return null;
            }

            async function writeMappingComment(targetNumber) {
              const marker = `<!-- MIRROR-TARGET:${pubOwner}/${pubRepo}#${targetNumber} -->`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: srcNumber,
                body: `Mirrored to ${pubOwner}/${pubRepo}#${targetNumber}\n\n${marker}`
              });
            }

            let mapping = await findMappingInPrivateComment();

            // --- Manejo de eventos sobre la issue ---
            if (context.eventName === 'issues') {
              const action = context.payload.action;

              if (!mapping) {
                // Crear issue pÃºblica nueva
                const { data: created } = await github.rest.issues.create({
                  owner: pubOwner,
                  repo: pubRepo,
                  title: srcIssue.title,
                  body: mirroredBody,
                  labels: ['from-private']
                });
                await writeMappingComment(created.number);
                mapping = { owner: pubOwner, repo: pubRepo, number: created.number };
              }

              // Sincronizar cambios
              if (['opened','edited','labeled','unlabeled'].includes(action)) {
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  title: srcIssue.title,
                  body: mirroredBody
                });
              }
              if (action === 'closed') {
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  state: 'closed'
                });
              }
              if (action === 'reopened') {
                await github.rest.issues.update({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  state: 'open'
                });
              }
            }

            // --- Manejo de comentarios ---
            if (context.eventName === 'issue_comment' && (process.env.COPY_COMMENTS || 'true').toLowerCase() === 'true') {
              const comment = context.payload.comment;
              if (comment.user && comment.user.type === 'Bot') return; // evitar loop

              if (!mapping) {
                const { data: created } = await github.rest.issues.create({
                  owner: pubOwner,
                  repo: pubRepo,
                  title: srcIssue.title,
                  body: mirroredBody,
                  labels: ['from-private']
                });
                await writeMappingComment(created.number);
                mapping = { owner: pubOwner, repo: pubRepo, number: created.number };
              }

              const safeComment = sanitize(comment.body || '');
              if (safeComment) {
                await github.rest.issues.createComment({
                  owner: mapping.owner,
                  repo: mapping.repo,
                  issue_number: mapping.number,
                  body: safeComment
                });
              }
            }
